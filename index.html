<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neural Network Word Trainer</title>
  <style>
    #output {
      font-size: 1.5em;
      margin-top: 20px;
    }
    canvas {
      border: 1px solid black;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <h1>Neural Network Word Trainer</h1>
  <input type="text" id="inputText" placeholder="Type a word" />
  <button onclick="trainNetwork()">Train Network</button>
  <div id="output">Output: </div>
  <canvas id="visualization" width="500" height="300"></canvas>

  <script>
    class NeuralNetwork {
      constructor(inputSize, hiddenSize, outputSize) {
        this.inputSize = inputSize;
        this.hiddenSize = hiddenSize;
        this.outputSize = outputSize;

        // Initialize weights with random values
        this.weightsInputHidden = Array.from({ length: inputSize }, () =>
          Array.from({ length: hiddenSize }, () => Math.random() - 0.5)
        );
        this.weightsHiddenOutput = Array.from({ length: hiddenSize }, () =>
          Array.from({ length: outputSize }, () => Math.random() - 0.5)
        );
        this.learningRate = 0.1;
      }

      // Sigmoid activation function
      sigmoid(x) {
        return 1 / (1 + Math.exp(-x));
      }

      // Derivative of the sigmoid
      sigmoidDerivative(x) {
        return x * (1 - x);
      }

      // Feedforward
      feedforward(input) {
        this.hiddenLayer = this.weightsInputHidden.map(row =>
          row.reduce((sum, w, i) => sum + w * input[i], 0)
        ).map(this.sigmoid);

        this.outputLayer = this.weightsHiddenOutput.map(row =>
          row.reduce((sum, w, i) => sum + w * this.hiddenLayer[i], 0)
        ).map(this.sigmoid);

        return this.outputLayer;
      }

      // Backpropagation to adjust weights
      train(input, target) {
        const output = this.feedforward(input);
        const outputError = target.map((t, i) => t - output[i]);
        const outputDelta = outputError.map((err, i) => err * this.sigmoidDerivative(output[i]));

        // Calculate hidden layer error and delta
        const hiddenError = this.weightsHiddenOutput[0].map((_, i) =>
          outputDelta.reduce((sum, delta, j) => sum + delta * this.weightsHiddenOutput[j][i], 0)
        );
        const hiddenDelta = hiddenError.map((err, i) => err * this.sigmoidDerivative(this.hiddenLayer[i]));

        // Update weights between hidden and output
        this.weightsHiddenOutput = this.weightsHiddenOutput.map((row, i) =>
          row.map((w, j) => w + this.learningRate * outputDelta[j] * this.hiddenLayer[i])
        );

        // Update weights between input and hidden
        this.weightsInputHidden = this.weightsInputHidden.map((row, i) =>
          row.map((w, j) => w + this.learningRate * hiddenDelta[j] * input[i])
        );
      }
    }

    // Create a neural network
    const neuralNetwork = new NeuralNetwork(26, 10, 26);

    function letterToArray(letter) {
      const index = letter.charCodeAt(0) - 65;
      const arr = new Array(26).fill(0);
      if (index >= 0 && index < 26) arr[index] = 1;
      return arr;
    }

    function arrayToLetter(arr) {
      const index = arr.indexOf(Math.max(...arr));
      return String.fromCharCode(65 + index);
    }

    function trainNetwork() {
      const inputText = document.getElementById('inputText').value.toUpperCase();
      const canvas = document.getElementById('visualization');
      const ctx = canvas.getContext('2d');
      const epochs = 1000;

      // Train the network on each letter of the input text
      for (let epoch = 0; epoch < epochs; epoch++) {
        for (let i = 0; i < inputText.length; i++) {
          const input = letterToArray(inputText[i]);
          const target = letterToArray(inputText[i]);  // Target is the same as input in this simple case
          neuralNetwork.train(input, target);
        }

        if (epoch % 100 === 0) {
          visualizeNetwork(ctx, epoch);
        }
      }

      const generatedWord = inputText.split('').map(letter => {
        const input = letterToArray(letter);
        const output = neuralNetwork.feedforward(input);
        return arrayToLetter(output);
      }).join('');

      document.getElementById('output').innerText = `Output after training: ${generatedWord}`;
    }

    function visualizeNetwork(ctx, epoch) {
      // Clear canvas
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

      // Draw the structure of the neural network
      ctx.font = '16px Arial';
      ctx.fillText(`Epoch: ${epoch}`, 20, 20);

      // Draw input layer
      for (let i = 0; i < 26; i++) {
        ctx.fillStyle = 'gray';
        ctx.fillRect(50, 50 + i * 8, 10, 10);
      }

      // Draw hidden layer
      for (let i = 0; i < 10; i++) {
        ctx.fillStyle = 'blue';
        ctx.fillRect(200, 50 + i * 25, 10, 10);
      }

      // Draw output layer
      for (let i = 0; i < 26; i++) {
        ctx.fillStyle = 'red';
        ctx.fillRect(350, 50 + i * 8, 10, 10);
      }

      ctx.fillText('Input Layer', 50, 40);
      ctx.fillText('Hidden Layer', 200, 40);
      ctx.fillText('Output Layer', 350, 40);
    }
  </script>
</body>
</html>

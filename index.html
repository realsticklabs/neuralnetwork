<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neural Network Word Trainer</title>
  <style>
    #output {
      font-size: 1.5em;
      margin-top: 20px;
    }
    canvas {
      border: 1px solid black;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <h1>Neural Network Word Trainer</h1>
  <input type="text" id="inputText" placeholder="Type a word" />
  <button onclick="trainNetwork()">Train Network</button>
  <div id="output">Output: </div>
  <canvas id="visualization" width="1000" height="100"></canvas>

  <script>
    class NeuralNetwork {
      constructor(inputSize, hiddenSize, outputSize) {
        this.inputSize = inputSize;
        this.hiddenSize = hiddenSize;
        this.outputSize = outputSize;

        // Initialize weights with random values
        this.weightsInputHidden = Array.from({ length: inputSize }, () =>
          Array.from({ length: hiddenSize }, () => Math.random() - 0.5)
        );
        this.weightsHiddenOutput = Array.from({ length: hiddenSize }, () =>
          Array.from({ length: outputSize }, () => Math.random() - 0.5)
        );
        this.learningRate = 0.1;
      }

      sigmoid(x) {
        return 1 / (1 + Math.exp(-x));
      }

      sigmoidDerivative(x) {
        return x * (1 - x);
      }

      feedforward(input) {
        this.hiddenLayer = this.weightsInputHidden.map(row =>
          row.reduce((sum, w, i) => sum + w * input[i], 0)
        ).map(this.sigmoid);

        this.outputLayer = this.weightsHiddenOutput.map(row =>
          row.reduce((sum, w, i) => sum + w * this.hiddenLayer[i], 0)
        ).map(this.sigmoid);

        return this.outputLayer;
      }

      train(input, target) {
        const output = this.feedforward(input);
        const outputError = target.map((t, i) => t - output[i]);
        const outputDelta = outputError.map((err, i) => err * this.sigmoidDerivative(output[i]));

        const hiddenError = this.weightsHiddenOutput[0].map((_, i) =>
          outputDelta.reduce((sum, delta, j) => sum + delta * this.weightsHiddenOutput[j][i], 0)
        );
        const hiddenDelta = hiddenError.map((err, i) => err * this.sigmoidDerivative(this.hiddenLayer[i]));

        this.weightsHiddenOutput = this.weightsHiddenOutput.map((row, i) =>
          row.map((w, j) => w + this.learningRate * outputDelta[j] * this.hiddenLayer[i])
        );

        this.weightsInputHidden = this.weightsInputHidden.map((row, i) =>
          row.map((w, j) => w + this.learningRate * hiddenDelta[j] * input[i])
        );
      }
    }

    const neuralNetwork = new NeuralNetwork(26, 10, 26);

    function letterToArray(letter) {
      const index = letter.charCodeAt(0) - 65;
      const arr = new Array(26).fill(0);
      if (index >= 0 && index < 26) arr[index] = 1;
      return arr;
    }

    function arrayToLetter(arr) {
      const index = arr.indexOf(Math.max(...arr));
      return String.fromCharCode(65 + index);
    }

    function trainNetwork() {
      const inputText = document.getElementById('inputText').value.toUpperCase();
      const canvas = document.getElementById('visualization');
      const ctx = canvas.getContext('2d');
      const epochs = 1000;

      // Train the network on each letter of the input text
      for (let epoch = 0; epoch < epochs; epoch++) {
        for (let i = 0; i < inputText.length; i++) {
          const input = letterToArray(inputText[i]);
          const target = letterToArray(inputText[i]);
          neuralNetwork.train(input, target);
        }

        // Every epoch, generate the word and write it to the canvas
        const generatedWord = inputText.split('').map(letter => {
          const input = letterToArray(letter);
          const output = neuralNetwork.feedforward(input);
          return arrayToLetter(output);
        }).join('');

        visualizeNetworkProgress(ctx, generatedWord, epoch);
      }

      // Final output
      const finalGeneratedWord = inputText.split('').map(letter => {
        const input = letterToArray(letter);
        const output = neuralNetwork.feedforward(input);
        return arrayToLetter(output);
      }).join('');
      document.getElementById('output').innerText = `Final Output: ${finalGeneratedWord}`;
    }

    function visualizeNetworkProgress(ctx, generatedWord, epoch) {
      const x = epoch % ctx.canvas.width;
      const y = Math.floor(epoch / ctx.canvas.width) * 20 + 20;

      if (y > ctx.canvas.height - 20) return;

      ctx.clearRect(x, y - 20, ctx.canvas.width, 20);  // Clear previous word at this position
      ctx.font = '16px Arial';
      ctx.fillText(generatedWord, x, y);  // Draw word at the pixel position of this epoch
    }
  </script>
</body>
</html>
